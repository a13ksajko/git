#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#define DELAY 500000
char *forks;									//1)обозначаем указатель под массив вилок
pthread_t thread[5];								//2)обозначаем массив потоков
pthread_mutex_t *marr=NULL;							//3)инициализируем указатель *marr пдо массив мьютексов и присваиваем NULL, чтобы не словить мусор

void fail(int i){
	printf("Phil %d is thinking\n",i);					//34)выводим сообщение о том, что философ думает, так как кушац не может
	usleep(DELAY);								//35)ждёт 0,5 сек, имитируя мыслительную деятельность
}

void win(int i){
	printf("Phil %d is eating\n",i);					//20)выводим сообщение от том, что философ номер i ест
	usleep(DELAY);								//21)спим пол секудны (DELAY описан в #define DELAY), чтобы имитировать сон
}

void initarr(){
	marr=malloc(sizeof(pthread_mutex_t)*5);					//7)в указателе *marr выделяем место под 5 мьютексов
	for(int i=0;i<5;i++)							//8)за за 5 циклов for инициализируем все мьютексы с помощью функции pthread_mutex_init,
		pthread_mutex_init(&marr[i],NULL);				//в которую мы передаем адресс соответствующего мьютекса и NULL - аргумент ОБЫЧНОЙ инициализации											  //(без каких-либо доп параметров)				
}										
										
char try_lock_fork(int i){
	return !pthread_mutex_trylock(&marr[i]);				//блочим мьютекс вилки, и, если это срабатывает, мы получаем из функции pthread_mutex_trylock 0,
}										//но возвращаем мы !0 равное хз чему, но не нулю, значит - истина

void release(int i){								
	pthread_mutex_trylock(&marr[i]);					//24/28)сначала пытаемся залочить мьютекс вилки, чтобы не заанлочить уже свободную вилку
	pthread_mutex_unlock(&marr[i]);						//25/29)освобождаем мьютекс вилки
}

void *eat(void *arg){								//10)как только создаётся поток, он запускает функцию *eat
	int i=*((int*)arg);							//11)т.к. мы считываем void, сначала мы должны превратить в int наш адрес, а потом разыменовывать его   
	int this=i;								//12)переменная this отвечает за "данную" вилку
	int next=(i==4)?0:i+1;							//13)переменная next - следущая за this вилка... [3]
	while(1){								//14)цикл, работающий до тех пор, пока "философ не наестся" 
		if(try_lock_fork(this)){					//15)проверяем, можем ли мы зарезервировать "данную" вилку
			forks[this]=1;						//16)если мы заблочили мьютекс вилки, то блочим саму вилку... [4]
			if(try_lock_fork(next)){				//17)так как философу надо 2 вилки, пытаемся заблочить следущую ... [5]
				forks[next]=1;					//18)если получается заблочить мьютекс следующей вилки, берём её
				win(i+1);					//19)при условии наличия 2 вилок, философ ест (функция win)
				forks[this]=0;					//22)теперь после того, как философ поел, мы освобождаем "его" вилку
				release(this);					//23)освобождаем мьютекс "нашей" вилки
				forks[next]=0;					//26)освобождаем вилку следущего философа
				release(next);					//27)освобождаем мьютекс "следующей" вилки
				break;						//30)выходим из бесконечного цикла, так как наш философ поел
			}else{
				forks[this]=0;					//31)если next вилка занята, освобождаем нашу вилку
				release(this);					//32)освобождаем мьютекс нашей вилки
				fail(i+1);					//33)философ ждёт
				
			}
		}else{
			fail(i+1);						//36)если наша вилка занята, то философ думает с помощбю функции fail()
		}
	}
	return NULL;								//37)при окончании работы eat поток возвращает NULL
}

int main(){									//4)после объявления глобалок идём в int main()
	forks=calloc(sizeof(char),5);						//5)в указателе *forks выделяем место под 5 char`ов
	initarr();								//6)инициализируем массив мьютексов с помощью функции initarr() 
	for(int i=0;i<5;i++){							//9)за 5 циклов for мы: 
		int *icopy=malloc(sizeof(int));					//создаём указатель-копию icopy, выделяем ему место под один int
		*icopy=i;							//присваиваем в *icopy номер цикла/потока... [1]
		pthread_create(&(thread[i]),NULL,&(eat),icopy);			//вызываем функцию pthread_create, которая создаёт ОБЫЧНЫЙ поток, запускает функцию eat и считывает свой 
	}									//номер...[2]
	void *retval;
	for(int i=0;i<5;i++)							//38)считываем за цикл for возвращаемые NULL с каждого потока 
		pthread_join(thread[i],&retval); 				// в переменную retval по адресу
	return 0;								//gg...[6]
}

//[1] - мы создаём копию i, так как отдав его самого в функцию, он будет в ней изменяться, из-за чего цикл пойдёт по ...
//так же он может пойти (а мы вместе с ним), если мы дадим ему не указатель, а обычный адрес переменной (вместо icopy(указатель) дать &icopy(int)

//[2] - когда мы пишем NULL в функцию pthread_create, мы сообщаем ей, что создаём поток без доп параметров
 
//[3] - в этом тернарном ифе мы проверяем возможность того, что наш философ - последний (в указателе нумерация элементов идёт с 0, следовательно последний философ - 4)
//и если это так, то делаем следущего философа под номером 0 (он у нас первый)

//[4] - в данном решении массив вилок - дополнительная вещь для понимания(по сути, они являются визуализацией мьютексов вилок, которые могут заняты/свободны), задача решается и без
//вилок, используя только лишь массив мьютексов 

//[5] - в данном решении взять вилку мы может только у следущего философа, а не у предыдущего

//[6] - надеюсь, объяснил хоть как-то, во многих местах спорные моменты решались проверкой; советую и вам сделать копию этой проги и проверять в копии все спорные места(например, зачем //мы блочим уже заблоченный мьютекс при его разблокировке в функции release())
//Так же уточню, что я не спец в потоках, любую информацию стоит уточнять в мануалах непонятных вам функций




